  
  对象的内存空间只包含数据成员，并不存储有关成员函数的信息。
图中虚线表示类和成员函数具有隶属关系，编译器只根据数据类型翻译成员函数的地址并判断调用的合法性。

1 Point *p=&c;
2 cout<<"area of Circle is<<p->area()<<endl;

静态联编：
  虽然用c的地址初始化也是枉然，p的原始类型是point，它的指针只能调用对象c的基类的area函数。引用Point &rc=c;的情况也一样。
  编译器编译成员函数是根据数据类型，类型是实现决定了的，所以由静态联编决定。

动态联编：执行1时，只根据赋值兼容性原则检查合理性。
  编译器为含有虚函数的类，将为它建立一个函数表，编译器也为类增加一个数据成员，即vptr指针。
  编译器为含有虚函数的对象，将为它建立指针，然后利用vptr，填入虚函数表。

假设Point中 virtual double area （）{  }
  
多态发生条件：
 1.类之间的继承关系满足赋值兼容性
 2.改写同名函数
 3.根据赋值兼容性规则使用用指针或引用//如基对象名调用虚函数不发生多态，poit *ptr=&c;用ptr->去调用重载的函数，也就发生多态。
